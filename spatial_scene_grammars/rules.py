import torch

from .nodes import SpatialNode

class ProductionRule(object):
    ''' Abstract interface for a production rule, which samples
    concrete instantiations of a set of product nodes given
    a parent node.
        Production rules should always output the same number and
    type of nodes -- they're meant to be the "continuous" part of a
    factorization of the grammar spec into discrete and continuous
    parts. So at construction time, the child types are registered
    (which helps the scene tree generate unique meaningful names). '''
    def __init__(self, child_types):
        ''' Register the fixed list of child types that
        will be generated by this rule. '''
        self.child_types = child_types

    def sample_products(self, parent, child_names):
        ''' Produces a set of child nodes. They should each have
            globally unique names; to make that easier, the calling
            method will provide a unique prefix.
        args:
            parent: the NonTerminalNode using this rule
            child_names: A list of names to pass through to children.
        returns: a list of instantiated nodes
        '''
        raise NotImplementedError()


class RandomRelativePoseProductionRule(ProductionRule):
    ''' Helper ProductionRule type representing random placement,
    described by a distribution on relative pose between two nodes. '''
    def __init__(self, child_type, relative_tf_sampler,  child_postfix="", **kwargs):
        ''' Args:
                child_type: Child node type. Should be a subclass of SpatialNode.
                relative_tf_sampler: callable that samples a 4x4 tf.
                kwargs: Additional arguments passed to the child.
        '''
        assert issubclass(child_type, SpatialNode)
        self.relative_tf_sampler = relative_tf_sampler
        self.child_postfix = child_postfix
        self.kwargs = kwargs
        super().__init__(child_types=[child_type])

    def sample_products(self, parent, child_names):
        assert(isinstance(parent, SpatialNode))
        assert(len(child_names) == 1)
        new_tf = torch.mm(parent.tf, self.relative_tf_sampler())
        return [self.child_types[0](
            name=child_names[0] + self.child_postfix,
            tf=new_tf,
            **self.kwargs)]

class DeterministicRelativePoseProductionRule(RandomRelativePoseProductionRule):
    ''' Helper ProductionRule type representing
    deterministic relative offsets between two nodes that have poses.

    In practice, shells out toe RandomRelativePoseProductionRule, but supplies
    a deterministic sampler. '''
    def __init__(self, child_type, relative_tf, **kwargs):
        ''' Args:
                child_type: Callable that takes `name` and `tf` args,
                    and produces a Node with SpatialNode.
                relative_tf: 4x4 torch tf matrix.
        '''
        RandomRelativePoseProductionRule.__init__(
            self,
            child_type,
            lambda: relative_tf,
            **kwargs
        )
