import torch
import pyro

from .nodes import SpatialNode, Node

class ProductionRule(object):
    ''' Abstract interface for a production rule, which samples
    concrete instantiations of a set of product nodes given
    a parent node.
        Production rules should always output the same number and
    type of nodes -- they're meant to be the "continuous" part of a
    factorization of the grammar spec into discrete and continuous
    parts. So at construction time, the child types are registered
    (which helps the scene tree generate unique meaningful names). '''
    def __init__(self, child_types, verify=True):
        ''' Register the fixed list of child types that
        will be generated by this rule. '''
        self.verify = verify
        self.child_types = child_types
        self.trace = None

    def sample_products(self, parent, child_names):
        ''' 
            Wraps _sample_products in a trace, keeping track of
            the identity of the variables that are sampled by the node
            production.
        args:
            parent: the NonTerminalNode using this rule
            child_names: A list of names to pass through to children.
        returns: a list of instantiated nodes
        '''
        self.trace = pyro.poutine.trace(self._sample_products).get_trace(parent, child_names)
        if self.verify:
            # Make sure that all sampled variables are continuous.
            for key, value in self.trace.nodes.items():
                if key not in ("_RETURN", "_INPUT"):
                    if value["type"] == "sample":
                        support = value["fn"].support
                        # TODO: Expand to exhaustive list of
                        # all continuous distribution constraint / support
                        # types. I didn't see any obvious inheritence hierarchy
                        # I can take advantage of to make this easier...
                        assert isinstance(
                            support,
                            (torch.distributions.constraints._Real,
                             torch.distributions.constraints._Interval)
                        ), "Sample sites in sample_products should only sample continuous " \
                           "values: this one has support " + str(support)
        return self.trace.nodes["_RETURN"]["value"]

    def _sample_products(self, parent, child_names):
        ''' Produces a set of child nodes. They should each have
            globally unique names; to make that easier, the calling
            method will provide a unique prefix.
        args:
            parent: the NonTerminalNode using this rule
            child_names: A list of names to pass through to children.
        returns: a list of instantiated nodes
        '''
        raise NotImplementedError()

    def get_local_variable_names(self):
        assert self.trace, "sample_products not called yet for rule " + str(self)
        return [key for key in list(self.trace.nodes.keys()) if key not in ["_RETURN", "_INPUT"]]


class SimpleProductionRule(ProductionRule):
    ''' Helper Rule that takes a class type and an argument set,
    and instantiates that class with that argument set at production time. '''
    def __init__(self, child_type, **kwargs):
        assert issubclass(child_type, Node)
        self.kwargs = kwargs
        super().__init__(child_types=[child_type])
    def _sample_products(self, parent, child_names):
        assert(isinstance(parent, Node))
        assert(len(child_names) == 1)
        return [self.child_types[0](
            name=child_names[0],
            **self.kwargs)]
        
class RandomRelativePoseProductionRule(ProductionRule):
    ''' Helper ProductionRule type representing random placement,
    described by a distribution on relative pose between two nodes. '''
    def __init__(self, child_type, relative_tf_sampler,  child_postfix="", **kwargs):
        ''' Args:
                child_type: Child node type. Should be a subclass of SpatialNode.
                relative_tf_sampler: callable that samples a 4x4 tf.
                kwargs: Additional arguments passed to the child.
        '''
        assert issubclass(child_type, SpatialNode)
        self.relative_tf_sampler = relative_tf_sampler
        self.child_postfix = child_postfix
        self.kwargs = kwargs
        super().__init__(child_types=[child_type])

    def _sample_products(self, parent, child_names):
        assert(isinstance(parent, SpatialNode))
        assert(len(child_names) == 1)
        new_tf = torch.mm(parent.tf, self.relative_tf_sampler())
        return [self.child_types[0](
            name=child_names[0] + self.child_postfix,
            tf=new_tf,
            **self.kwargs)]

class DeterministicRelativePoseProductionRule(RandomRelativePoseProductionRule):
    ''' Helper ProductionRule type representing
    deterministic relative offsets between two nodes that have poses.

    In practice, shells out toe RandomRelativePoseProductionRule, but supplies
    a deterministic sampler. '''
    def __init__(self, child_type, relative_tf, **kwargs):
        ''' Args:
                child_type: Callable that takes `name` and `tf` args,
                    and produces a Node with SpatialNode.
                relative_tf: 4x4 torch tf matrix.
        '''
        RandomRelativePoseProductionRule.__init__(
            self,
            child_type,
            lambda: relative_tf,
            **kwargs
        )
