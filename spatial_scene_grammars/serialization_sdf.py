from copy import deepcopy
import networkx as nx
import numpy as np
import os
import shutil
import yaml
from lxml import etree as et
et.register_namespace('drake', 'drake.mit.edu')

import torch

import pydrake
from pydrake.all import (
    AngleAxis,
    AddMultibodyPlantSceneGraph,
    DiagramBuilder,
    FixedOffsetFrame,
    MultibodyPlant,
    Parser,
    RigidTransform,
    RollPitchYaw,
    RotationMatrix,
)
import pydrake.geometry as pydrake_geom

from .tree import get_tree_root
from .drake_interop import torch_tf_to_drake_tf, resolve_catkin_package_path, default_friction


def make_sdf_root():
    # SDF tag
    sdf_root = et.Element("sdf", version="1.6")
    return sdf_root


def tf_from_pose_tag(pose_tag):
    if "relative_to" in pose_tag.attrib.keys():
        raise NotImplementedError("Relative to pose not handled")
    nums = [float(x) for x in pose_tag.text.split()]
    print(pose_tag.text, "::", nums)
    return RigidTransform(p=nums[:3], rpy=RollPitchYaw(nums[-3:]))


def add_pose_tag(parent_item, tf, relative_to=None):
    assert isinstance(tf, RigidTransform)
    attrib = {}
    if relative_to:
        attrib["relative_to"] = relative_to
    pose_item = et.SubElement(parent_item, "pose", attrib=attrib)
    xyz = tf.translation()
    rpy = RollPitchYaw(tf.rotation()).vector()
    pose_item.text = "%f %f %f %f %f %f" % (
        xyz[0], xyz[1], xyz[2], rpy[0], rpy[1], rpy[2]
    )


def add_inertial_tag(parent_item, mass, com=None, I=None):
    # Inertial info
    inertia = node.spatial_inertia
    inertial_item = et.SubElement(link_item, 'inertial')
    add_pose_tag(inertial_item, RigidTransform(p=inertia.get_com()))
    mass_item = et.SubElement(inertial_item, 'mass')
    mass_item.text = '{:.2E}'.format(inertia.get_mass())
    I = [['{:.4E}'.format(y) for y in x]  # NOQA
         for x in inertia.CalcRotationalInertia().CopyToFullMatrix3()[:]]
    inertia_item = et.SubElement(inertial_item, 'inertia')
    for name, val in zip(["ixx", "ixy", "ixz", "iyy", "iyz", "izz"],
                    [I[0][0], I[0][1], I[0][2], I[1][1], I[1][2], I[2][2]]):
        i_subelem = et.SubElement(inertia_item, name)
        i_subelem.text = str(val)


def add_node_to_sdf_root(sdf_root, node, link_name, include_static_tag=True, 
                         include_model_files=True, pybullet_compat=True):
    ''' Adds the given node to the sdf as a new model instance,
    using the node name as the model instance, and adding the
    node visual and collision geometry to a single link.

    Other args:
    - include_static_tag: If include_static_tag is True, we'll indicate that
      this model if the node is. *Not* doing this can be useful if the
      model is going to be programmatically welded to another model
      down the road, in which case this static flag can cause issues
      (see Drake issue #12227).
    - include_model_files: If true, we'll literally paste in
      the SDFs that the node tries to include as additional models
      (with unique name generated by appending the model name + a unique
      number to the node name). If false, we'll only handle registered
      geometry and will ignored referenced SDFs.)
    - pybullet_compat: If we're including model files, pybullet needs
      a `world` link to be created in each model for world-welding purposes,
      or so I think from some testing... this does that.
    '''
    if not isinstance(node, PhysicsGeometryNode):
        return

    model_item = et.SubElement(sdf_root, "model", name=node.name)
    link_item = et.SubElement(model_item, "link", name=link_name)
    add_pose_tag(model_item, torch_tf_to_drake_tf(node.tf))

    static_item = et.SubElement(model_item, "static")
    if include_static_tag and node.fixed:
        static_item.text = "1"
    else:
        static_item.text = "0"

    # Inertial info
    inertia = node.spatial_inertia
    inertial_item = et.SubElement(link_item, 'inertial')
    add_pose_tag(inertial_item, RigidTransform(p=inertia.get_com()))
    mass_item = et.SubElement(inertial_item, 'mass')
    mass_item.text = str(inertia.get_mass())
    I = [['{:.4E}'.format(y) for y in x]  # NOQA
         for x in inertia.CalcRotationalInertia().CopyToFullMatrix3()[:]]
    inertia_item = et.SubElement(inertial_item, 'inertia')
    for name, val in zip(["ixx", "ixy", "ixz", "iyy", "iyz", "izz"],
                    [I[0][0], I[0][1], I[0][2], I[1][1], I[1][2], I[2][2]]):
        i_subelem = et.SubElement(inertia_item, name)
        i_subelem.text = str(val)
    
    def make_common_geometry_items(parent_item, tf, geometry):
        # Parent item is "visual" or "collision" item
        add_pose_tag(parent_item, tf)
        geometry_item = et.SubElement(parent_item, "geometry")
        if isinstance(geometry, pydrake_geom.Box):
            box_item = et.SubElement(geometry_item, "box")
            size_item = et.SubElement(box_item, "size")
            size_item.text = "%f %f %f" % (
                geometry.width(),
                geometry.depth(),
                geometry.height()
            )
        elif isinstance(geometry, pydrake_geom.Sphere):
            sphere_item = et.SubElement(geometry_item, "sphere")
            radus_item = et.SubElement(sphere_item, "radus")
            radius.text = "%f" % geometry_item.radius()
        elif isinstance(geometry, pydrake_geom.Cylinder):
            cylinder_item = et.SubElement(geometry_item, "cylinder")
            radius_item = et.SubElement(cylinder_item, "radius")
            radius_item.text = "%f" % geometry.radius()
            length_item = et.SubElement(cylinder_item, "length")
            length_item.text = "%f" % geometry.length()
        elif isinstance(geometry, pydrake_geom.Mesh) or isinstance(geometry, pydrake_geom.Convex):
            mesh_item = et.SubElement(geometry_item, "mesh")
            uri_item = et.SubElement(mesh_item, "uri")
            uri_item.text = geometry.filename()
            scale_item = et.SubElement(mesh_item, "scale")
            scale_item.text = "%f %f %f" % (
                geometry.scale(),
                geometry.scale(),
                geometry.scale()
            )
            if isinstance(geometry, pydrake_geom.Convex):
                et.SubElement(mesh_item, '{drake.mit.edu}declare_convex')
        else:
            raise NotImplementedError("Geometry type ", geometry)

    # Add geometries.
    for k, (tf, geometry, color) in enumerate(node.visual_geometry):
        visual_item = et.SubElement(link_item, "visual", name="visual_%d" % k)
        make_common_geometry_items(visual_item, torch_tf_to_drake_tf(tf), geometry)
        material_item = et.SubElement(visual_item, "material")
        diffuse_item = et.SubElement(material_item, "diffuse")
        diffuse_item.text = "%f %f %f %f" % (color[0], color[1], color[2], color[3])

    for k, (tf, geometry, friction) in enumerate(node.collision_geometry):
        collision_item = et.SubElement(link_item, "collision", name="collision_%d" % k)
        make_common_geometry_items(collision_item, torch_tf_to_drake_tf(tf), geometry)
        geometry_item = et.SubElement(collision_item, "geometry")
        compliance_item = et.SubElement(visual_item, "drake_compliance")
        static_friction = et.SubElement(compliance_item, "static_friction")
        static_friction.text = "%f" % friction.static_friction()
        dynamic_friction = et.SubElement(compliance_item, "dynamic_friction")
        dynamic_friction.text = "%f" % friction.dynamic_friction()

    # Paste in included model files, if requested.
    if include_model_files:
        # Make a dummy system so we can resolve ROS package paths
        dummy_parser = Parser(MultibodyPlant(0.))
        dummy_parser.package_map().PopulateFromEnvironment("ROS_PACKAGE_PATH")
        # And make an XML parser for reading the SDFs
        parser = et.XMLParser(remove_blank_text=True)
        for k, (tf, model_path, root_body_name, q0_dict) in enumerate(node.model_paths):
            # Open up the indicated SDF as XML
            full_model_path = resolve_catkin_package_path(dummy_parser.package_map(), model_path)

            data = et.parse(full_model_path, parser=parser)
            imported_sdf_root = data.getroot()
            model_items = imported_sdf_root.findall('.//model')
            assert len(model_items) == 1, "Can't handle more than one model in an included SDF."
            # Fix model name to be unique
            model_item = deepcopy(model_items[0])
            new_model_name = node.name + "::" + model_item.attrib["name"] + "_%d" % k
            model_item.attrib["name"] = new_model_name

            # Make appropriate modifications to model.
            # Set model pose, which is specified in node frame, so multiply out to world frame.
            add_pose_tag(model_item, torch_tf_to_drake_tf(node.tf).multiply(torch_tf_to_drake_tf(tf)))
            # Add the requested weld if this model is static.
            if node.fixed:
                # Necessary in pybullet, but breaks drake. Why?!
                if pybullet_compat:
                    world_item = et.SubElement(model_item, "link", name="world")
                weld_item = et.SubElement(model_item, "joint", name="%s_weld_to_%s" % (node.name, new_model_name), type="fixed")
                parent_item = et.SubElement(weld_item, "parent")
                parent_item.text = "world"
                child_item = et.SubElement(weld_item, "child")
                if root_body_name:
                    child_item.text = root_body_name
                else:
                    link_items = model_item.findall(".//link")
                    assert len(link_items) == 1, "Specify root_body_name in model %s with more than 1 link" % model_path
                    child_item.text = link_items[0].attrib["name"]

            # Update all uris:
            for uri_item in model_item.findall(".//uri"):
                uri = uri_item.text
                # If it doesn't have a package prefix, and it's not a global path,
                # it's a relative path to the SDF.
                if "://" not in uri and uri[0] != "/":
                    uri = os.path.join(os.path.split(full_model_path)[0], uri)
                    uri_item.text = uri

            # Go set the default joint state of nodes specified in q0_dict.
            for joint_name in list(q0_dict.keys()):
                q0 = np.array(q0_dict[joint_name]).flatten()
                assert len(q0) == 1 or len(q0) == 2, (joint_name, q0)
                joint_items = model_item.xpath("//joint[@name='%s']" % joint_name)
                assert len(joint_items) == 1, "Found %d instances of joint named %s" % (len(joint_items), joint_name)
                axis_items = joint_items[0].findall(".//axis")

                if len(q0) >= 1:
                    axis_items = joint_items[0].findall("axis")
                    assert len(axis_items) == 1
                    initial_position_item = et.SubElement(axis_items[0], "initial_position")
                    initial_position_item.text = str(q0[0])
                if len(q0) == 2:
                    axis_items = joint_items[0].findall("axis2")
                    assert len(axis_items) == 1
                    initial_position_item = et.SubElement(axis_items[0], "initial_position")
                    initial_position_item.text = str(q0[1])

            # Apply a patch to the joints to deal with pybullet issue #2651: joint poses are ignored.
            # Instead, we'll insert a very-low-inertia dummy link between the joint
            # and the child link, positioned such that it acts like the joint offset.
            if pybullet_compat:
                for joint_item in model_item.findall(".//joint"):
                    pose_item = joint_item.find("pose")
                    if pose_item is not None:
                        assert "relative_to" not in pose_item.attrib.keys()

                        # Find the corresponding child element.
                        child_name_item = joint_item.find("child")
                        assert child_name_item is not None, "Joint %s has no child" % joint_item.attrib["name"]

                        child_items = model_item.xpath("//link[@name='%s']" % child_name_item.text)
                        assert len(child_items) == 1
                        child_item = child_items[0]

                        # Extract its pose and calculate desired pose offset
                        # for the dummy link.
                        child_pose_item = child_item.find("pose")
                        if child_pose_item is not None:
                            child_tf = tf_from_pose_tag(child_pose_item)
                        else:
                            child_tf = RigidTransform()
                        joint_tf = tf_from_pose_tag(pose_item)
                        # The joint's pose is defined in child link frame by default,
                        # while a link is defined in the model frame. So figure out what
                        # the model-frame pose of the joint was supposed to be by multiply
                        # it into the child pose.
                        desired_dummy_link_tf = child_tf.multiply(joint_tf)

                        # Add corresponding dummy link at the joint's intended pose offset,
                        # and remove pose from the joint.
                        new_link_name = "%s_pose_dummy_link" % joint_item.attrib["name"]
                        dummy_link_item = et.Element("link", name=new_link_name)
                        add_pose_tag(dummy_link_item, desired_dummy_link_tf)
                        joint_item.remove(pose_item)
                        # Add the new link item before the joint.
                        model_item.insert(model_item.getchildren().index(joint_item), dummy_link_item)

                        # Weld dummy link to actual child object.
                        dummy_weld_item = et.Element("joint", name=new_link_name + "_weld", type="fixed")
                        parent_item = et.SubElement(dummy_weld_item, "parent")
                        parent_item.text = new_link_name
                        child_item = et.SubElement(dummy_weld_item, "child")
                        child_item.text = child_name_item.text
                        # Add weld in after the dummy link and before the real link.
                        model_item.insert(model_item.getchildren().index(joint_item), dummy_weld_item)

                        # Finally, set child of joint to our new dummy link.
                        child_name_item.text = new_link_name


            sdf_root.append(model_item)



    return


def save_sdf_with_node_geometry(node, path, link_name, **kwargs):
    ''' Given a node, creates an SDF that has just this node's
    geometry in it. Returns True if an SDF was created, or False if not.
    (If the node doesn't have geometry, no SDF will be made.)

    **kwargs are passed through to add_node_to_sdf_root. '''
    if len(node.collision_geometry) == 0 and len(node.visual_geometry) == 0:
        return False

    sdf_root = make_sdf_root()
    add_node_to_sdf_root(sdf_root, node, link_name, **kwargs)
    
    need_dir, _ = os.path.split(path)
    os.makedirs(need_dir, exist_ok=True)
    et.ElementTree(sdf_root).write(path, pretty_print=True)
    return True


def add_subtree_to_sdf_root(sdf_root, scene_tree, node, **kwargs):
    # Recursively add each node to the tree, adding welds and
    # relative poses appropriately.
    add_node_to_sdf_root(sdf_root, node, node.name, **kwargs)
    for rule in scene_tree.successors(node):
        for child_node in scene_tree.successors(rule):
            # TODO: We could have the appropriate hierarchy of welds
            # by looking at parent/child relationships here.
            # But since things are either fixed to the world or floating,
            # it doesn't make a difference...
            add_subtree_to_sdf_root(sdf_root, scene_tree, child_node, **kwargs)


def serialize_scene_tree_to_package_and_single_sdf(
        scene_tree, out_sdf_name, **kwargs):
    ''' Given a scene tree, serializes it out to one large SDF file that
    references all of the relevant models.

    Kwargs get passed through to add_node_to_sdf_root. See that doc
    for the options.
    '''

    sdf_root = make_sdf_root()
    root_node = get_tree_root(scene_tree)
    add_subtree_to_sdf_root(sdf_root, scene_tree, root_node, **kwargs)

    et.ElementTree(sdf_root).write(out_sdf_name, pretty_print=True)



